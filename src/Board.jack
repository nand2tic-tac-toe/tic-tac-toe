class Board {
    // 0: пустая клетка, 1: нолик, 2: крестик
    field Array boardArray;
    // Количество пустых клеток
    field int emptyCellsCount;
    // Состояние поля
    // 0 - ряд, 1-столбик, 2 - верхняя диаг, 3 - нижняя диагональ
    field int winVariable; 
    field boolean isPlayerWin;
    field boolean isDraw;
    // По каким рядам/столбцам победа
    field int winRow, winCol; 
    // Параметры
    field int boardX, boardY, boardSize, thickness, cellSize, finishLineThickness;

    constructor Board new(int x,int y) {
        let boardArray = Array.new(9);	
		let boardX = x;
		let boardY = y;
		let boardSize = 120;
		let thickness = 4;
		let finishLineThickness = 4;
		let cellSize = boardSize/3;

		do clear();
		do drawBoard();

		return this;
	}

    method void drawWin() {
		if (winVariable = 0) {
			do rowWin(winRow);
		}
		if (winVariable = 1) {
			do colWin(winCol);
		}
		if (winVariable = 2) {
			do topDiagonalWin();
		}
		if (winVariable = 3) {
			do botDiagonalWin();
		}
		return;
	}

    method boolean isWin() {
		return isPlayerWin;
	}
	
	method boolean isDraw() {
		return isDraw;
	}

    method int getEmptyCellsCount() {
		return emptyCellsCount;
	}


    // Чистим ресурсики (доску, память)
    method void dispose() {
        do Screen.setColor(false);
		do Screen.drawRectangle(boardX,boardY,boardX+boardSize, boardY+boardSize);
		do Screen.setColor(true);
		do Memory.deAlloc(boardArray);
		return;
	}

    // А тут просто очищаем доску
    method void clear() {
		var int i;
		let emptyCellsCount = 9;
		while(i < 9) {
			let boardArray[i] = 0;
			let i = i + 1;
		}
		return;
	}


    function void main() {
        do Screen.clearScreen();
        do drawBoard();

        return;
    }


    method void drawBoard() {
        // Рисование вертикальных линий
        do Screen.drawLine(170, 0, 170, 255);
        do Screen.drawLine(340, 0, 340, 255);

        // Рисование горизонтальных линий
        do Screen.drawLine(0, 85, 511, 85);
        do Screen.drawLine(0, 170, 511, 170);
        return;
    }


    method void rowWin(int row){
        var int y, displacement;
		let y = (cellSize/2) + boardY + (row * cellSize); 
		let displacement = finishLineThickness/2;
		do Screen.drawRectangle(boardX, y - displacement, boardX + boardSize, y + displacement);
		return; 
    }

    method void colWin(int col){
        var int x, displacement;
		let x = (cellSize/2) + boardX + (col *cellSize);
		let displacement = finishLineThickness/2;
		do Screen.drawRectangle(x - displacement, boardY, x + displacement, boardY + boardSize);
		return;
    }

    method void botDiagonalWin() {
    var int i, x, y; 
    let x = boardX; 
    let y = boardY; 
    let i = finishLineThickness - 1; 

    // (нижняя диагональ)
    while (~(i < 0)) {
        //(от левого нижнего угла к правому верхнему)
        do Screen.drawLine(x, y + boardSize - i, x + boardSize - i, y);
        //(от левого верхнего угла к правому нижнему)
        do Screen.drawLine(x + i, y + boardSize, x + boardSize, y + i);
        let i = i - 1; 
    }
    return;
    }

    method void topDiagonalWin() {
    var int i, x, y; 
    let x = boardX; 
    let y = boardY; 
    let i = finishLineThickness - 1; //  счётчик для толщины линии

    while (~(i < 0)) {
        // (от левого верхнего угла к правому нижнему)
        do Screen.drawLine(x + i, y, x + boardSize, y + boardSize - i);
        // (от левого нижнего угла к правому верхнему)
        do Screen.drawLine(x, y + i, x + boardSize - i, y + boardSize);
        let i = i - 1; // Уменьшаем счётчик
    }
    return;
    }

    method int posToIndex(int row, int col) {
		return col+(row*3);
	}
	
	method boolean isFree(int row, int col) {
		if(boardArray[posToIndex(row,col)]=0) {
			return true;
		}
        else {
			return false;
		}
	}


    method void evaluate() {
		var int r,c,b1,b2,b3;
		let isPlayerWin = false;
		let isDraw = false;
		let r = 0;
		let c = 0;

		while(r<3) {
			let b1 = boardArray[posToIndex(r,0)];
			let b2 = boardArray[posToIndex(r,1)];
			let b3 = boardArray[posToIndex(r,2)];
			if((b1=b2) & (b2=b3) & (b1>0)) {
				let isPlayerWin = true;
				let winVariable = 0;
				let winRow = r;
				return;
			}
			let r = r+1;
		}
		while(c<3) {
			let b1 = boardArray[posToIndex(0,c)];
			let b2 = boardArray[posToIndex(1,c)];
			let b3 = boardArray[posToIndex(2,c)];
			if((b1=b2) & (b2=b3)& (b1>0)) {
				let isPlayerWin = true;
				let winVariable = 1;
				let winCol = c;
				return;
			}
			let c = c+1;
		}
		
		let b1 = boardArray[0];
		let b2 = boardArray[4];
		let b3 = boardArray[8];
		if((b1=b2) & (b2=b3)& (b1>0)) {
			let isPlayerWin = true;
			let winVariable = 2;
			return;
		}
		
		let b1 = boardArray[6];
		let b2 = boardArray[4];
		let b3 = boardArray[2];
		if((b1=b2) & (b2=b3)& (b1>0)) {
			let isPlayerWin = true;
			let winVariable = 3;
			return;
		}
		
		if(emptyCellsCount=0) {
			let isDraw = true;
			return;
		}
		return ;
	}

    // добавляем наш ход
    method void makeMove(int row, int col, Mark p) {
        // Устанавливаем тип фигуры (крестик или нолик) в указанной клетке
        let boardArray[posToIndex(row, col)] = p.getType();
        let emptyCellsCount = emptyCellsCount - 1;
        return;
    }
        // рисуем наш ход
    method void drawMove(int row, int col, Mark p) {
        var int xl, yt; 
        // находим х(центрируем по гориз.)
        let xl = boardX + (col * cellSize) + ((cellSize - p.getWidth()) / 2);
        // находим у(центрируем по верт.)
        let yt = boardY + (row * cellSize) + ((cellSize - p.getHeight()) / 2);
        // Отрисовываем фигуру на доске
        do p.drawMark(xl, yt);
        return;
    }

    // отменa хода
    method void takeBackMove(int row, int col, Mark p) {
        let boardArray[posToIndex(row, col)] = 0;
        let emptyCellsCount = emptyCellsCount + 1;
        return;
    }

    method Array getAvailableMoves() {
        var Array moves;
		var int r1,c1,counter;
		let r1 = 0;
		let c1 = 0;
		let moves = Array.new(emptyCellsCount * 2);
		let counter = 0;
		while(r1<3) {
			let c1 = 0;
			while(c1<3) {
				if(boardArray[posToIndex(r1,c1)]=0) {
					let moves[counter] = r1;
					let moves[counter+1] = c1;
					let counter = counter + 2;
				}
				let c1 = c1 + 1;
			}
			let r1 = r1 + 1;
		}
		return moves;
	}
}
